/* esm.sh - esbuild bundle(oidc-token-hash@5.0.3) denonext production */
import __Process$ from "node:process";
import { Buffer as __Buffer$ } from "node:buffer";
import * as __0$ from "node:assert";
import * as __1$ from "node:crypto";
import * as __2$ from "node:util";
import * as __3$ from "node:crypto";
var require=n=>{const e=m=>typeof m.default<"u"?m.default:m,c=m=>Object.assign({},m);switch(n){case"assert":return e(__0$);case"crypto":return e(__1$);case"util":return e(__2$);default:throw new Error("module \""+n+"\" not found");}};
var T=Object.create;var l=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var R=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var u=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var m=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),z=(e,t)=>{for(var r in t)l(e,r,{get:t[r],enumerable:!0})},p=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of P(t))!j.call(e,n)&&n!==r&&l(e,n,{get:()=>t[n],enumerable:!(o=k(t,n))||o.enumerable});return e},a=(e,t,r)=>(p(e,t,"default"),r&&p(r,t,"default")),S=(e,t,r)=>(r=e!=null?T(R(e)):{},p(t||!e||!e.__esModule?l(r,"default",{value:e,enumerable:!0}):r,e));var w=m((F,E)=>{var A=u("crypto"),[y,B]=__Process$.version.substring(1).split(".").map(e=>parseInt(e,10)),D=y>12||y===12&&B>=8,L=D&&A.getHashes().includes("shake256");E.exports=L});var f=m((G,x)=>{var{strict:g}=u("assert"),{createHash:i}=u("crypto"),{format:v}=u("util"),$=w(),h;if(__Buffer$.isEncoding("base64url"))h=e=>e.toString("base64url");else{let e=t=>t.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");h=t=>e(t.toString("base64"))}function I(e,t){switch(e){case"HS256":case"RS256":case"PS256":case"ES256":case"ES256K":return i("sha256");case"HS384":case"RS384":case"PS384":case"ES384":return i("sha384");case"HS512":case"RS512":case"PS512":case"ES512":return i("sha512");case"EdDSA":switch(t){case"Ed25519":return i("sha512");case"Ed448":if(!$)throw new TypeError("Ed448 *_hash calculation is not supported in your Node.js runtime version");return i("shake256",{outputLength:114});default:throw new TypeError("unrecognized or invalid EdDSA curve provided")}default:throw new TypeError("unrecognized or invalid JWS algorithm provided")}}function b(e,t,r){let o=I(t,r).update(e).digest();return h(o.slice(0,o.length/2))}function J(e,t,r,o,n){if(typeof e.claim!="string"||!e.claim)throw new TypeError("names.claim must be a non-empty string");if(typeof e.source!="string"||!e.source)throw new TypeError("names.source must be a non-empty string");g(typeof t=="string"&&t,`${e.claim} must be a non-empty string`),g(typeof r=="string"&&r,`${e.source} must be a non-empty string`);let d,c;try{d=b(r,o,n)}catch(H){c=v("%s could not be validated (%s)",e.claim,H.message)}c=c||v("%s mismatch, expected %s, got: %s",e.claim,d,t),g.equal(d,t,c)}x.exports={validate:J,generate:b}});var s={};z(s,{default:()=>W,generate:()=>N,validate:()=>K});var q=S(f());a(s,S(f()));var{validate:K,generate:N}=q,{default:_,...O}=q,W=_!==void 0?_:O;export{W as default,N as generate,K as validate};
//# sourceMappingURL=oidc-token-hash.mjs.map