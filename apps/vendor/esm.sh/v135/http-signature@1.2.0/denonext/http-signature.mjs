/* esm.sh - esbuild bundle(http-signature@1.2.0) denonext production */
import { Buffer as __Buffer$ } from "node:buffer";
import * as __0$ from "/v135/assert-plus@1.0.0/denonext/assert-plus.mjs";
import * as __1$ from "node:util";
import * as __2$ from "/v135/assert-plus@1.0.0/denonext/assert-plus.mjs";
import * as __3$ from "node:crypto";
import * as __4$ from "node:http";
import * as __5$ from "node:util";
import * as __6$ from "/v135/sshpk@1.18.0/denonext/sshpk.mjs";
import * as __7$ from "/v135/jsprim@1.4.2/denonext/jsprim.mjs";
import * as __8$ from "/v135/assert-plus@1.0.0/denonext/assert-plus.mjs";
import * as __9$ from "node:crypto";
import * as __a$ from "/v135/sshpk@1.18.0/denonext/sshpk.mjs";
import * as __b$ from "/v135/assert-plus@1.0.0/denonext/assert-plus.mjs";
import * as __c$ from "/v135/sshpk@1.18.0/denonext/sshpk.mjs";
import * as __d$ from "node:util";
var require=n=>{const e=m=>typeof m.default<"u"?m.default:m,c=m=>Object.assign({},m);switch(n){case"assert-plus":return e(__0$);case"util":return e(__1$);case"crypto":return e(__3$);case"http":return e(__4$);case"sshpk":return e(__6$);case"jsprim":return e(__7$);default:throw new Error("module \""+n+"\" not found");}};
var Ce=Object.create;var V=Object.defineProperty;var Ke=Object.getOwnPropertyDescriptor;var Ie=Object.getOwnPropertyNames;var Pe=Object.getPrototypeOf,qe=Object.prototype.hasOwnProperty;var u=(a=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(a,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):a)(function(a){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+a+'" is not supported')});var _=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),be=(a,e)=>{for(var r in e)V(a,r,{get:e[r],enumerable:!0})},N=(a,e,r,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of Ie(e))!qe.call(a,i)&&i!==r&&V(a,i,{get:()=>e[i],enumerable:!(s=Ke(e,i))||s.enumerable});return a},S=(a,e,r)=>(N(a,e,"default"),r&&N(r,e,"default")),ie=(a,e,r)=>(r=a!=null?Ce(Pe(a)):{},N(e||!a||!a.__esModule?V(r,"default",{value:a,enumerable:!0}):r,a));var C=_((Xe,oe)=>{var j=u("assert-plus"),z=u("sshpk"),se=u("util"),ne={sha1:!0,sha256:!0,sha512:!0},he={rsa:!0,dsa:!0,ecdsa:!0};function E(a,e){Error.captureStackTrace&&Error.captureStackTrace(this,e||E),this.message=a,this.name=e.name}se.inherits(E,Error);function A(a){E.call(this,a,A)}se.inherits(A,E);function Te(a){var e=a.toLowerCase().split("-");if(e.length!==2)throw new A(e[0].toUpperCase()+" is not a valid algorithm");if(e[0]!=="hmac"&&!he[e[0]])throw new A(e[0].toUpperCase()+" type keys are not supported");if(!ne[e[1]])throw new A(e[1].toUpperCase()+" is not a supported hash algorithm");return e}oe.exports={HASH_ALGOS:ne,PK_ALGOS:he,HttpSignatureError:E,InvalidAlgorithmError:A,validateAlgorithm:Te,sshKeyToPEM:function(e){j.string(e,"ssh_key");var r=z.parseKey(e,"ssh");return r.toString("pem")},fingerprint:function(e){j.string(e,"ssh_key");var r=z.parseKey(e,"ssh");return r.fingerprint("md5").toString("hex")},pemToRsaSSHKey:function(e,r){j.equal("string",typeof e,"typeof pem");var s=z.parseKey(e,"pem");return s.comment=r,s.toString("ssh")}}});var fe=_((er,ge)=>{var K=u("assert-plus"),P=u("util"),q=C(),Ye=q.HASH_ALGOS,$e=q.PK_ALGOS,p=q.HttpSignatureError,Le=q.InvalidAlgorithmError,xe=q.validateAlgorithm,x={New:0,Params:1},c={Name:0,Quote:1,Value:2,Comma:3};function D(a){p.call(this,a,D)}P.inherits(D,p);function m(a){p.call(this,a,m)}P.inherits(m,p);function R(a){p.call(this,a,R)}P.inherits(R,p);function I(a){p.call(this,a,I)}P.inherits(I,p);function F(a){p.call(this,a,F)}P.inherits(F,p);ge.exports={parseRequest:function(e,r){K.object(e,"request"),K.object(e.headers,"request.headers"),r===void 0&&(r={}),r.headers===void 0&&(r.headers=[e.headers["x-date"]?"x-date":"date"]),K.object(r,"options"),K.arrayOfString(r.headers,"options.headers"),K.optionalFinite(r.clockSkew,"options.clockSkew");var s=r.authorizationHeaderName||"authorization";if(!e.headers[s])throw new I("no "+s+" header present in the request");r.clockSkew=r.clockSkew||300;var i=0,f=x.New,n=c.Name,o="",g="",t={scheme:"",params:{},signingString:""},d=e.headers[s];for(i=0;i<d.length;i++){var l=d.charAt(i);switch(Number(f)){case x.New:l!==" "?t.scheme+=l:f=x.Params;break;case x.Params:switch(Number(n)){case c.Name:var v=l.charCodeAt(0);if(v>=65&&v<=90||v>=97&&v<=122)o+=l;else if(l==="="){if(o.length===0)throw new m("bad param format");n=c.Quote}else throw new m("bad param format");break;case c.Quote:if(l==='"')g="",n=c.Value;else throw new m("bad param format");break;case c.Value:l==='"'?(t.params[o]=g,n=c.Comma):g+=l;break;case c.Comma:if(l===",")o="",n=c.Name;else throw new m("bad param format");break;default:throw new Error("Invalid substate")}break;default:throw new Error("Invalid substate")}}if(!t.params.headers||t.params.headers===""?e.headers["x-date"]?t.params.headers=["x-date"]:t.params.headers=["date"]:t.params.headers=t.params.headers.split(" "),!t.scheme||t.scheme!=="Signature")throw new m('scheme was not "Signature"');if(!t.params.keyId)throw new m("keyId was not specified");if(!t.params.algorithm)throw new m("algorithm was not specified");if(!t.params.signature)throw new m("signature was not specified");t.params.algorithm=t.params.algorithm.toLowerCase();try{xe(t.params.algorithm)}catch(k){throw k instanceof Le?new R(t.params.algorithm+" is not supported"):k}for(i=0;i<t.params.headers.length;i++){var w=t.params.headers[i].toLowerCase();if(t.params.headers[i]=w,w==="request-line")if(!r.strict)t.signingString+=e.method+" "+e.url+" HTTP/"+e.httpVersion;else throw new F("request-line is not a valid header with strict parsing enabled.");else if(w==="(request-target)")t.signingString+="(request-target): "+e.method.toLowerCase()+" "+e.url;else{var ae=e.headers[w];if(ae===void 0)throw new I(w+" was not in the request");t.signingString+=w+": "+ae}i+1<t.params.headers.length&&(t.signingString+=`
`)}var U;if(e.headers.date||e.headers["x-date"]){e.headers["x-date"]?U=new Date(e.headers["x-date"]):U=new Date(e.headers.date);var Ee=new Date,te=Math.abs(Ee.getTime()-U.getTime());if(te>r.clockSkew*1e3)throw new D("clock skew of "+te/1e3+"s was greater than "+r.clockSkew+"s")}if(r.headers.forEach(function(k){if(t.params.headers.indexOf(k.toLowerCase())<0)throw new I(k+" was not a signed header")}),r.algorithms&&r.algorithms.indexOf(t.params.algorithm)===-1)throw new R(t.params.algorithm+" is not a supported algorithm");return t.algorithm=t.params.algorithm.toUpperCase(),t.keyId=t.params.keyId,t}}});var ve=_((ar,pe)=>{var h=u("assert-plus"),ue=u("crypto"),rr=u("http"),de=u("util"),O=u("sshpk"),le=u("jsprim"),T=C(),Q=u("util").format,Re=T.HASH_ALGOS,me=T.PK_ALGOS,b=T.InvalidAlgorithmError,G=T.HttpSignatureError,J=T.validateAlgorithm,Z='Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';function W(a){G.call(this,a,W)}de.inherits(W,G);function X(a){G.call(this,a,X)}de.inherits(X,G);function H(a){h.object(a,"options");var e=[];if(a.algorithm!==void 0&&(h.string(a.algorithm,"options.algorithm"),e=J(a.algorithm)),this.rs_alg=e,a.sign!==void 0)h.func(a.sign,"options.sign"),this.rs_signFunc=a.sign;else if(e[0]==="hmac"&&a.key!==void 0){if(h.string(a.keyId,"options.keyId"),this.rs_keyId=a.keyId,typeof a.key!="string"&&!__Buffer$.isBuffer(a.key))throw new TypeError("options.key for HMAC must be a string or Buffer");this.rs_signer=ue.createHmac(e[1].toUpperCase(),a.key),this.rs_signer.sign=function(){var s=this.digest("base64");return{hashAlgorithm:e[1],toString:function(){return s}}}}else if(a.key!==void 0){var r=a.key;if((typeof r=="string"||__Buffer$.isBuffer(r))&&(r=O.parsePrivateKey(r)),h.ok(O.PrivateKey.isPrivateKey(r,[1,2]),"options.key must be a sshpk.PrivateKey"),this.rs_key=r,h.string(a.keyId,"options.keyId"),this.rs_keyId=a.keyId,!me[r.type])throw new b(r.type.toUpperCase()+" type keys are not supported");if(e[0]!==void 0&&r.type!==e[0])throw new b("options.key must be a "+e[0].toUpperCase()+" key, was given a "+r.type.toUpperCase()+" key instead");this.rs_signer=r.createSign(e[1])}else throw new TypeError("options.sign (func) or options.key is required");this.rs_headers=[],this.rs_lines=[]}H.prototype.writeHeader=function(a,e){if(h.string(a,"header"),a=a.toLowerCase(),h.string(e,"value"),this.rs_headers.push(a),this.rs_signFunc)this.rs_lines.push(a+": "+e);else{var r=a+": "+e;this.rs_headers.length>0&&(r=`
`+r),this.rs_signer.update(r)}return e};H.prototype.writeDateHeader=function(){return this.writeHeader("date",le.rfc1123(new Date))};H.prototype.writeTarget=function(a,e){h.string(a,"method"),h.string(e,"path"),a=a.toLowerCase(),this.writeHeader("(request-target)",a+" "+e)};H.prototype.sign=function(a){if(h.func(a,"callback"),this.rs_headers.length<1)throw new Error("At least one header must be signed");var e,r;if(this.rs_signFunc){var s=this.rs_lines.join(`
`),i=this;this.rs_signFunc(s,function(o,g){if(o){a(o);return}try{h.object(g,"signature"),h.string(g.keyId,"signature.keyId"),h.string(g.algorithm,"signature.algorithm"),h.string(g.signature,"signature.signature"),e=J(g.algorithm),r=Q(Z,g.keyId,g.algorithm,i.rs_headers.join(" "),g.signature)}catch(t){a(t);return}a(null,r)})}else{try{var f=this.rs_signer.sign()}catch(o){a(o);return}e=(this.rs_alg[0]||this.rs_key.type)+"-"+f.hashAlgorithm;var n=f.toString();r=Q(Z,this.rs_keyId,e,this.rs_headers.join(" "),n),a(null,r)}};pe.exports={isSigner:function(a){return typeof a=="object"&&a instanceof H},createSigner:function(e){return new H(e)},signRequest:function(e,r){h.object(e,"request"),h.object(r,"options"),h.optionalString(r.algorithm,"options.algorithm"),h.string(r.keyId,"options.keyId"),h.optionalArrayOfString(r.headers,"options.headers"),h.optionalString(r.httpVersion,"options.httpVersion"),e.getHeader("Date")||e.setHeader("Date",le.rfc1123(new Date)),r.headers||(r.headers=["date"]),r.httpVersion||(r.httpVersion="1.1");var s=[];r.algorithm&&(r.algorithm=r.algorithm.toLowerCase(),s=J(r.algorithm));var i,f="";for(i=0;i<r.headers.length;i++){if(typeof r.headers[i]!="string")throw new TypeError("options.headers must be an array of Strings");var n=r.headers[i].toLowerCase();if(n==="request-line")if(!r.strict)f+=e.method+" "+e.path+" HTTP/"+r.httpVersion;else throw new X("request-line is not a valid header with strict parsing enabled.");else if(n==="(request-target)")f+="(request-target): "+e.method.toLowerCase()+" "+e.path;else{var o=e.getHeader(n);if(o===void 0||o==="")throw new W(n+" was not in the request");f+=n+": "+o}i+1<r.headers.length&&(f+=`
`)}e.hasOwnProperty("_stringToSign")&&(e._stringToSign=f);var g;if(s[0]==="hmac"){if(typeof r.key!="string"&&!__Buffer$.isBuffer(r.key))throw new TypeError("options.key must be a string or Buffer");var t=ue.createHmac(s[1].toUpperCase(),r.key);t.update(f),g=t.digest("base64")}else{var d=r.key;if((typeof d=="string"||__Buffer$.isBuffer(d))&&(d=O.parsePrivateKey(r.key)),h.ok(O.PrivateKey.isPrivateKey(d,[1,2]),"options.key must be a sshpk.PrivateKey"),!me[d.type])throw new b(d.type.toUpperCase()+" type keys are not supported");if(s[0]!==void 0&&d.type!==s[0])throw new b("options.key must be a "+s[0].toUpperCase()+" key, was given a "+d.type.toUpperCase()+" key instead");var l=d.createSign(s[1]);l.update(f);var v=l.sign();if(!Re[v.hashAlgorithm])throw new b(v.hashAlgorithm.toUpperCase()+" is not a supported hash algorithm");r.algorithm=d.type+"-"+v.hashAlgorithm,g=v.toString(),h.notStrictEqual(g,"","empty signature produced")}var w=r.authorizationHeaderName||"Authorization";return e.setHeader(w,Q(Z,r.keyId,r.algorithm,r.headers.join(" "),g)),!0}}});var Se=_((hr,ye)=>{var M=u("assert-plus"),Y=u("crypto"),ce=u("sshpk"),L=C(),tr=L.HASH_ALGOS,ir=L.PK_ALGOS,sr=L.InvalidAlgorithmError,nr=L.HttpSignatureError,we=L.validateAlgorithm;ye.exports={verifySignature:function(e,r){M.object(e,"parsedSignature"),(typeof r=="string"||__Buffer$.isBuffer(r))&&(r=ce.parseKey(r)),M.ok(ce.Key.isKey(r,[1,1]),"pubkey must be a sshpk.Key");var s=we(e.algorithm);if(s[0]==="hmac"||s[0]!==r.type)return!1;var i=r.createVerify(s[1]);return i.update(e.signingString),i.verify(e.params.signature,"base64")},verifyHMAC:function(e,r){M.object(e,"parsedHMAC"),M.string(r,"secret");var s=we(e.algorithm);if(s[0]!=="hmac")return!1;var i=s[1].toUpperCase(),f=Y.createHmac(i,r);f.update(e.signingString);var n=Y.createHmac(i,r);n.update(f.digest()),n=n.digest();var o=Y.createHmac(i,r);return o.update(new __Buffer$(e.params.signature,"base64")),o=o.digest(),typeof n=="string"?n===o:__Buffer$.isBuffer(n)&&!n.equals?n.toString("binary")===o.toString("binary"):n.equals(o)}}});var re=_((or,He)=>{var Ae=fe(),B=ve(),$=Se(),ee=C();He.exports={parse:Ae.parseRequest,parseRequest:Ae.parseRequest,sign:B.signRequest,signRequest:B.signRequest,createSigner:B.createSigner,isSigner:B.isSigner,sshKeyToPEM:ee.sshKeyToPEM,sshKeyFingerprint:ee.fingerprint,pemToRsaSSHKey:ee.pemToRsaSSHKey,verify:$.verifySignature,verifySignature:$.verifySignature,verifyHMAC:$.verifyHMAC}});var y={};be(y,{createSigner:()=>Ue,default:()=>Je,isSigner:()=>Ne,parse:()=>Oe,parseRequest:()=>Ge,pemToRsaSSHKey:()=>ze,sign:()=>Me,signRequest:()=>Be,sshKeyFingerprint:()=>je,sshKeyToPEM:()=>Ve,verify:()=>De,verifyHMAC:()=>Qe,verifySignature:()=>Fe});var _e=ie(re());S(y,ie(re()));var{parse:Oe,parseRequest:Ge,sign:Me,signRequest:Be,createSigner:Ue,isSigner:Ne,sshKeyToPEM:Ve,sshKeyFingerprint:je,pemToRsaSSHKey:ze,verify:De,verifySignature:Fe,verifyHMAC:Qe}=_e,{default:ke,...Ze}=_e,Je=ke!==void 0?ke:Ze;export{Ue as createSigner,Je as default,Ne as isSigner,Oe as parse,Ge as parseRequest,ze as pemToRsaSSHKey,Me as sign,Be as signRequest,je as sshKeyFingerprint,Ve as sshKeyToPEM,De as verify,Qe as verifyHMAC,Fe as verifySignature};
//# sourceMappingURL=http-signature.mjs.map