/* esm.sh - esbuild bundle(openid-client@5.6.1) denonext production */
import __Process$ from "node:process";
import { Buffer as __Buffer$ } from "node:buffer";
import * as __0$ from "node:crypto";
import * as __1$ from "node:util";
import * as __2$ from "node:util";
import * as __3$ from "node:url";
import * as __4$ from "node:url";
import * as __5$ from "node:util";
import * as __6$ from "node:assert";
import * as __7$ from "node:querystring";
import * as __8$ from "node:http";
import * as __9$ from "node:https";
import * as __a$ from "node:events";
import * as __b$ from "node:url";
import * as __c$ from "/v135/lru-cache@6.0.0/denonext/lru-cache.mjs";
import * as __d$ from "node:http";
import * as __e$ from "node:util";
import * as __f$ from "/v135/object-hash@2.2.0/denonext/object-hash.mjs";
import * as __10$ from "/v135/lru-cache@6.0.0/denonext/lru-cache.mjs";
import * as __11$ from "/v135/lru-cache@6.0.0/denonext/lru-cache.mjs";
import * as __12$ from "/v135/jose@4.15.4/denonext/jose.mjs";
import * as __13$ from "/v135/jose@4.15.4/denonext/jose.mjs";
import * as __14$ from "node:util";
import * as __15$ from "node:http";
import * as __16$ from "node:crypto";
import * as __17$ from "node:assert";
import * as __18$ from "node:querystring";
import * as __19$ from "node:url";
import * as __1a$ from "/v135/jose@4.15.4/denonext/jose.mjs";
import * as __1b$ from "/v135/oidc-token-hash@5.0.3/denonext/oidc-token-hash.mjs";
import * as __1c$ from "node:util";
import * as __1d$ from "node:crypto";
import * as __1e$ from "node:util";
var require=n=>{const e=m=>typeof m.default<"u"?m.default:m,c=m=>Object.assign({},m);switch(n){case"crypto":return e(__0$);case"util":return e(__1$);case"url":return e(__3$);case"assert":return e(__6$);case"querystring":return e(__7$);case"http":return e(__8$);case"https":return e(__9$);case"events":return e(__a$);case"lru-cache":return e(__c$);case"object-hash":return e(__f$);case"jose":return c(__12$);case"oidc-token-hash":return e(__1b$);default:throw new Error("module \""+n+"\" not found");}};
var bs=Object.create;var Ye=Object.defineProperty;var ks=Object.getOwnPropertyDescriptor;var Es=Object.getOwnPropertyNames;var Ss=Object.getPrototypeOf,js=Object.prototype.hasOwnProperty;var l=(i=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(i,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):i)(function(i){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+i+'" is not supported')});var _=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports);var Ts=(i,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Es(e))!js.call(i,n)&&n!==t&&Ye(i,n,{get:()=>e[n],enumerable:!(r=ks(e,n))||r.enumerable});return i};var xs=(i,e,t)=>(t=i!=null?bs(Ss(i)):{},Ts(e||!i||!i.__esModule?Ye(t,"default",{value:i,enumerable:!0}):t,i));var x=_((ci,Xe)=>{var{format:Qe}=l("util"),re=class extends Error{constructor({error_description:e,error:t,error_uri:r,session_state:n,state:o,scope:a},s){super(e?`${t} (${e})`:t),Object.assign(this,{error:t},e&&{error_description:e},r&&{error_uri:r},o&&{state:o},a&&{scope:a},n&&{session_state:n}),s&&Object.defineProperty(this,"response",{value:s}),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}},ie=class extends Error{constructor(...e){if(typeof e[0]=="string")super(Qe(...e));else{let{message:t,printf:r,response:n,...o}=e[0];r?super(Qe(...r)):super(t),Object.assign(this,o),n&&Object.defineProperty(this,"response",{value:n})}this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}};Xe.exports={OPError:re,RPError:ie}});var et=_((ui,Ze)=>{var Ps=l("util"),qs=l("crypto");Ze.exports=Ps.types.isKeyObject||(i=>i&&i instanceof qs.KeyObject)});var R=_((di,oe)=>{var ne;if(__Buffer$.isEncoding("base64url"))ne=(i,e="utf8")=>__Buffer$.from(i,e).toString("base64url");else{let i=e=>e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");ne=(e,t="utf8")=>i(__Buffer$.from(e,t).toString("base64"))}var vs=i=>__Buffer$.from(i,"base64");oe.exports.decode=vs;oe.exports.encode=ne});var rt=_((hi,st)=>{var tt=R();st.exports=i=>{if(typeof i!="string"||!i)throw new TypeError("JWT must be a string");let{0:e,1:t,2:r,length:n}=i.split(".");if(n===5)throw new TypeError("encrypted JWTs cannot be decoded");if(n!==3)throw new Error("JWTs must have three components");try{return{header:JSON.parse(tt.decode(e)),payload:JSON.parse(tt.decode(t)),signature:r}}catch{throw new Error("JWT is malformed")}}});var C=_((pi,it)=>{it.exports=i=>!!i&&i.constructor===Object});var de=_((fi,ue)=>{var ae=C();function ce(i,e,...t){for(let r of t)if(ae(r))for(let[n,o]of Object.entries(r))n==="__proto__"||n==="constructor"||(typeof e[n]>"u"&&typeof o<"u"&&(e[n]=o),i&&ae(e[n])&&ae(o)&&ce(!0,e[n],o));return e}ue.exports=ce.bind(void 0,!1);ue.exports.deep=ce.bind(void 0,!0)});var he=_((li,nt)=>{var As=/(\w+)=("[^"]*")/g;nt.exports=i=>{let e={};try{for(;As.exec(i)!==null;)RegExp.$1&&RegExp.$2&&(e[RegExp.$1]=RegExp.$2.slice(1,-1))}catch{}return e}});var N=_((_i,ot)=>{function Os(i,e,t){if(!e[`${i}_endpoint`])return;let r=`${i}_endpoint_auth_method`,n=`${i}_endpoint_auth_signing_alg`,o=`${i}_endpoint_auth_signing_alg_values_supported`;if(t[r]&&t[r].endsWith("_jwt")&&!t[n]&&!e[o])throw new TypeError(`${o} must be configured on the issuer if ${n} is not defined on a client`)}function Rs(i,e){if(!i[e])throw new TypeError(`${e} must be configured on the issuer`)}ot.exports={assertSigningAlgValuesSupport:Os,assertIssuerConfiguration:Rs}});var U=_((yi,at)=>{at.exports=function(e,...t){let r={};for(let n of t)e[n]!==void 0&&(r[n]=e[n]);return r}});var K=_((wi,ut)=>{var{STATUS_CODES:pe}=l("http"),{format:ct}=l("util"),{OPError:B}=x(),Cs=he(),$s=i=>{let e=Cs(i.headers["www-authenticate"]);if(e.error)throw new B(e,i)},Js=i=>{let e=!1;try{let t;typeof i.body!="object"||__Buffer$.isBuffer(i.body)?t=JSON.parse(i.body):t=i.body,e=typeof t.error=="string"&&t.error.length,e&&Object.defineProperty(i,"body",{value:t,configurable:!0})}catch{}return e};function Ws(i,{statusCode:e=200,body:t=!0,bearer:r=!1}={}){if(i.statusCode!==e)throw r&&$s(i),Js(i)?new B(i.body,i):new B({error:ct("expected %i %s, got: %i %s",e,pe[e],i.statusCode,pe[i.statusCode])},i);if(t&&!i.body)throw new B({error:ct("expected %i %s with body but no body was returned",e,pe[e])},i);return i.body}ut.exports=Ws});var $=_((mi,dt)=>{dt.exports=()=>Math.floor(Date.now()/1e3)});var le=_((gi,pt)=>{var zs=R(),ht=$(),fe=class{constructor(e){Object.assign(this,e);let{constructor:t,...r}=Object.getOwnPropertyDescriptors(this.constructor.prototype);Object.defineProperties(this,r)}set expires_in(e){this.expires_at=ht()+Number(e)}get expires_in(){return Math.max.apply(null,[this.expires_at-ht(),0])}expired(){return this.expires_in===0}claims(){if(!this.id_token)throw new TypeError("id_token not present in TokenSet");return JSON.parse(zs.decode(this.id_token.split(".")[1]))}};pt.exports=fe});var J=_((bi,lt)=>{var{createHash:Ds,randomBytes:Hs}=l("crypto"),ft=R(),M=(i=32)=>ft.encode(Hs(i));lt.exports={random:M,state:M,nonce:M,codeVerifier:M,codeChallenge:i=>ft.encode(Ds("sha256").update(i).digest())}});var _t=_((ki,Ns)=>{Ns.exports={name:"openid-client",version:"5.6.1",description:"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs",keywords:["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],homepage:"https://github.com/panva/node-openid-client",repository:"panva/node-openid-client",funding:{url:"https://github.com/sponsors/panva"},license:"MIT",author:"Filip Skokan <panva.ip@gmail.com>",exports:{types:"./types/index.d.ts",import:"./lib/index.mjs",require:"./lib/index.js"},main:"./lib/index.js",types:"./types/index.d.ts",files:["lib","types/index.d.ts"],scripts:{format:"npx prettier --loglevel silent --write ./lib ./test ./certification ./types",test:"mocha test/**/*.test.js"},dependencies:{jose:"^4.15.1","lru-cache":"^6.0.0","object-hash":"^2.2.0","oidc-token-hash":"^5.0.3"},devDependencies:{"@types/node":"^16.18.55","@types/passport":"^1.0.13",base64url:"^3.0.1",chai:"^4.3.10",mocha:"^10.2.0",nock:"^13.3.3",prettier:"^2.8.8","readable-mock-req":"^0.2.2",sinon:"^9.2.4",timekeeper:"^2.3.1"},"standard-version":{scripts:{postchangelog:"sed -i '' -e 's/### \\[/## [/g' CHANGELOG.md"},types:[{type:"feat",section:"Features"},{type:"fix",section:"Fixes"},{type:"chore",hidden:!0},{type:"docs",hidden:!0},{type:"style",hidden:!0},{type:"refactor",section:"Refactor",hidden:!1},{type:"perf",section:"Performance",hidden:!1},{type:"test",hidden:!0}]}}});var I=_((Ei,yt)=>{var Us=Symbol(),Bs=Symbol();yt.exports={CLOCK_TOLERANCE:Bs,HTTP_OPTIONS:Us}});var O=_((Si,we)=>{var Ks=l("assert"),Ms=l("querystring"),Is=l("http"),Ls=l("https"),{once:wt}=l("events"),{URL:Fs}=l("url"),Gs=l("lru-cache"),_e=_t(),{RPError:Vs}=x(),gt=U(),{deep:ye}=de(),{HTTP_OPTIONS:Ys}=I(),F,Qs=/^[\x21\x23-\x5B\x5D-\x7E]+$/,bt=["agent","ca","cert","crl","headers","key","lookup","passphrase","pfx","timeout"],kt=(i,e)=>{F=ye({},i.length?gt(e,...i):e,F)};kt([],{headers:{"User-Agent":`${_e.name}/${_e.version} (${_e.homepage})`},timeout:3500});function L(i,e,t){t&&(i.removeHeader("content-type"),i.setHeader("content-type",t)),e&&(i.removeHeader("content-length"),i.setHeader("content-length",__Buffer$.byteLength(e)),i.write(e)),i.end()}var mt=new Gs({max:100});we.exports=async function(e,{accessToken:t,mTLS:r=!1,DPoP:n}={}){let o;try{o=new Fs(e.url),delete e.url,Ks(/^(https?:)$/.test(o.protocol))}catch{throw new TypeError("only valid absolute URLs can be requested")}let a=this[Ys],s=e,u=`${o.origin}${o.pathname}`;n&&"dpopProof"in this&&(s.headers=s.headers||{},s.headers.DPoP=await this.dpopProof({htu:`${o.origin}${o.pathname}`,htm:e.method,nonce:mt.get(u)},n,t));let c;if(a&&(c=gt(a.call(this,o,ye({},s,F)),...bt)),s=ye({},c,s,F),r&&!s.pfx&&!(s.key&&s.cert))throw new TypeError("mutual-TLS certificate and key not set");if(s.searchParams)for(let[m,g]of Object.entries(s.searchParams))o.searchParams.delete(m),o.searchParams.set(m,g);let d,p,f,y;({form:p,responseType:d,json:f,body:y,...s}=s);for(let[m,g]of Object.entries(s.headers||{}))g===void 0&&delete s.headers[m];let w,T=(o.protocol==="https:"?Ls.request:Is.request)(o.href,s);return(async()=>{if(f?L(T,JSON.stringify(f),"application/json"):p?L(T,Ms.stringify(p),"application/x-www-form-urlencoded"):y?L(T,y):L(T),[w]=await Promise.race([wt(T,"response"),wt(T,"timeout")]),!w)throw T.destroy(),new Vs(`outgoing request timed out after ${s.timeout}ms`);let m=[];for await(let g of w)m.push(g);if(m.length)switch(d){case"json":{Object.defineProperty(w,"body",{get(){let g=__Buffer$.concat(m);try{g=JSON.parse(g)}catch(H){throw Object.defineProperty(H,"response",{value:w}),H}finally{Object.defineProperty(w,"body",{value:g,configurable:!0})}return g},configurable:!0});break}case void 0:case"buffer":{Object.defineProperty(w,"body",{get(){let g=__Buffer$.concat(m);return Object.defineProperty(w,"body",{value:g,configurable:!0}),g},configurable:!0});break}default:throw new TypeError("unsupported responseType request option")}return w})().catch(m=>{throw w&&Object.defineProperty(m,"response",{value:w}),m}).finally(()=>{let m=w&&w.headers["dpop-nonce"];m&&Qs.test(m)&&mt.set(u,m)})};we.exports.setDefaults=kt.bind(void 0,bt)});var G=_((ji,Et)=>{Et.exports.keystores=new WeakMap});var W=_((Ti,St)=>{St.exports=globalThis.structuredClone||(i=>JSON.parse(JSON.stringify(i)))});var ge=_((Pi,Pt)=>{var me=l("jose"),Xs=W(),jt=C(),Tt=Symbol(),xt=(i,{alg:e,use:t})=>{let r=0;return e&&i.alg&&r++,t&&i.use&&r++,r};function Zs(i){switch(typeof i=="string"&&i.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:return}}function er(i,e,t,r){if(e)return new Set([e]);switch(t){case"EC":{let n=[];if((i==="enc"||i===void 0)&&(n=n.concat(["ECDH-ES","ECDH-ES+A128KW","ECDH-ES+A192KW","ECDH-ES+A256KW"])),i==="sig"||i===void 0)switch(r){case"P-256":case"P-384":n=n.concat([`ES${r.slice(-3)}`.replace("21","12")]);break;case"P-521":n=n.concat(["ES512"]);break;case"secp256k1":me.cryptoRuntime==="node:crypto"&&(n=n.concat(["ES256K"]));break}return new Set(n)}case"OKP":return new Set(["ECDH-ES","ECDH-ES+A128KW","ECDH-ES+A192KW","ECDH-ES+A256KW"]);case"RSA":{let n=[];return(i==="enc"||i===void 0)&&(n=n.concat(["RSA-OAEP","RSA-OAEP-256","RSA-OAEP-384","RSA-OAEP-512"]),me.cryptoRuntime==="node:crypto"&&(n=n.concat(["RSA1_5"]))),(i==="sig"||i===void 0)&&(n=n.concat(["PS256","PS384","PS512","RS256","RS384","RS512"])),new Set(n)}default:throw new Error("unreachable")}}Pt.exports=class{#e;constructor(e,t){if(e!==Tt)throw new Error("invalid constructor call");this.#e=t}toJWKS(){return{keys:this.map(({jwk:{d:e,p:t,q:r,dp:n,dq:o,qi:a,...s}})=>s)}}all({alg:e,kid:t,use:r}={}){if(!r||!e)throw new Error;let n=Zs(e),o={alg:e,use:r};return this.filter(a=>{let s=!0;return s&&n!==void 0&&a.jwk.kty!==n&&(s=!1),s&&t!==void 0&&a.jwk.kid!==t&&(s=!1),s&&r!==void 0&&a.jwk.use!==void 0&&a.jwk.use!==r&&(s=!1),s&&a.jwk.alg&&a.jwk.alg!==e?s=!1:a.algorithms.has(e)||(s=!1),s}).sort((a,s)=>xt(s,o)-xt(a,o))}get(...e){return this.all(...e)[0]}static async fromJWKS(e,{onlyPublic:t=!1,onlyPrivate:r=!1}={}){if(!jt(e)||!Array.isArray(e.keys)||e.keys.some(o=>!jt(o)||!("kty"in o)))throw new TypeError("jwks must be a JSON Web Key Set formatted object");let n=[];for(let o of e.keys){o=Xs(o);let{kty:a,kid:s,crv:u}=o,{alg:c,use:d}=o;if(!(typeof a!="string"||!a)&&!(d!==void 0&&d!=="sig"&&d!=="enc")&&!(typeof c!="string"&&c!==void 0)&&!(typeof s!="string"&&s!==void 0)){if(a==="EC"&&d==="sig")switch(u){case"P-256":c="ES256";break;case"P-384":c="ES384";break;case"P-521":c="ES512";break;default:break}if(u==="secp256k1"&&(d="sig",c="ES256K"),a==="OKP")switch(u){case"Ed25519":case"Ed448":d="sig",c="EdDSA";break;case"X25519":case"X448":d="enc";break;default:break}if(c&&!d)switch(!0){case c.startsWith("ECDH"):d="enc";break;case c.startsWith("RSA"):d="enc";break;default:break}if(r&&(o.kty==="oct"||!o.d))throw new Error("jwks must only contain private keys");t&&(o.d||o.k)||n.push({jwk:{...o,alg:c,use:d},async keyObject(p){if(this[p])return this[p];let f=await me.importJWK(this.jwk,p);return this[p]=f,f},get algorithms(){return Object.defineProperty(this,"algorithms",{value:er(this.jwk.use,this.jwk.alg,this.jwk.kty,this.jwk.crv),enumerable:!0,configurable:!1}),this.algorithms}})}}return new this(Tt,n)}filter(...e){return this.#e.filter(...e)}find(...e){return this.#e.find(...e)}every(...e){return this.#e.every(...e)}some(...e){return this.#e.some(...e)}map(...e){return this.#e.map(...e)}forEach(...e){return this.#e.forEach(...e)}reduce(...e){return this.#e.reduce(...e)}sort(...e){return this.#e.sort(...e)}*[Symbol.iterator](){for(let e of this.#e)yield e}}});var At=_((qi,vt)=>{var be=C();function qt(i,...e){for(let t of e)if(be(t))for(let[r,n]of Object.entries(t))r==="__proto__"||r==="constructor"||(be(i[r])&&be(n)?i[r]=qt(i[r],n):typeof n<"u"&&(i[r]=n));return i}vt.exports=qt});var Ee=_((vi,$t)=>{var Ot=l("jose"),{RPError:ke}=x(),{assertIssuerConfiguration:tr}=N(),{random:sr}=J(),rr=$(),ir=O(),{keystores:nr}=G(),or=At(),Rt=i=>encodeURIComponent(i).replace(/%20/g,"+");async function ar(i,e){let t=this[`${i}_endpoint_auth_signing_alg`];if(t||tr(this.issuer,`${i}_endpoint_auth_signing_alg_values_supported`),this[`${i}_endpoint_auth_method`]==="client_secret_jwt"){if(!t){let o=this.issuer[`${i}_endpoint_auth_signing_alg_values_supported`];t=Array.isArray(o)&&o.find(a=>/^HS(?:256|384|512)/.test(a))}if(!t)throw new ke(`failed to determine a JWS Algorithm to use for ${this[`${i}_endpoint_auth_method`]} Client Assertion`);return new Ot.CompactSign(__Buffer$.from(JSON.stringify(e))).setProtectedHeader({alg:t}).sign(this.secretForAlg(t))}let r=await nr.get(this);if(!r)throw new TypeError("no client jwks provided for signing a client assertion with");if(!t){let o=this.issuer[`${i}_endpoint_auth_signing_alg_values_supported`];t=Array.isArray(o)&&o.find(a=>r.get({alg:a,use:"sig"}))}if(!t)throw new ke(`failed to determine a JWS Algorithm to use for ${this[`${i}_endpoint_auth_method`]} Client Assertion`);let n=r.get({alg:t,use:"sig"});if(!n)throw new ke(`no key found in client jwks to sign a client assertion with using alg ${t}`);return new Ot.CompactSign(__Buffer$.from(JSON.stringify(e))).setProtectedHeader({alg:t,kid:n.jwk&&n.jwk.kid}).sign(await n.keyObject(t))}async function Ct(i,{clientAssertionPayload:e}={}){switch(this[`${i}_endpoint_auth_method`]){case"self_signed_tls_client_auth":case"tls_client_auth":case"none":return{form:{client_id:this.client_id}};case"client_secret_post":if(typeof this.client_secret!="string")throw new TypeError("client_secret_post client authentication method requires a client_secret");return{form:{client_id:this.client_id,client_secret:this.client_secret}};case"private_key_jwt":case"client_secret_jwt":{let r=rr(),n=[...new Set([this.issuer.issuer,this.issuer.token_endpoint].filter(Boolean))],o=await ar.call(this,i,{iat:r,exp:r+60,jti:sr(),iss:this.client_id,sub:this.client_id,aud:n,...e});return{form:{client_id:this.client_id,client_assertion:o,client_assertion_type:"urn:ietf:params:oauth:client-assertion-type:jwt-bearer"}}}case"client_secret_basic":{if(typeof this.client_secret!="string")throw new TypeError("client_secret_basic client authentication method requires a client_secret");let r=`${Rt(this.client_id)}:${Rt(this.client_secret)}`;return{headers:{Authorization:`Basic ${__Buffer$.from(r).toString("base64")}`}}}default:throw new TypeError(`missing, or unsupported, ${i}_endpoint_auth_method`)}}function cr(){let{length:i,0:e}=this.response_types;if(i===1)return e}function ur(){let{length:i,0:e}=this.redirect_uris||[];if(i===1)return e}async function dr(i,e,{clientAssertionPayload:t,endpointAuthMethod:r=i,DPoP:n}={}){let o=await Ct.call(this,r,{clientAssertionPayload:t}),a=or(e,o),s=this[`${r}_endpoint_auth_method`].includes("tls_client_auth")||i==="token"&&this.tls_client_certificate_bound_access_tokens,u;if(s&&this.issuer.mtls_endpoint_aliases&&(u=this.issuer.mtls_endpoint_aliases[`${i}_endpoint`]),u=u||this.issuer[`${i}_endpoint`],"form"in a)for(let[c,d]of Object.entries(a.form))typeof d>"u"&&delete a.form[c];return ir.call(this,{...a,method:"POST",url:u,headers:{...i!=="revocation"?{Accept:"application/json"}:void 0,...a.headers}},{mTLS:s,DPoP:n})}$t.exports={resolveResponseType:cr,resolveRedirectUri:ur,authFor:Ct,authenticatedPost:dr}});var Te=_((Ai,je)=>{var hr=l("object-hash"),pr=l("lru-cache"),{RPError:Jt}=x(),{assertIssuerConfiguration:fr}=N(),lr=ge(),{keystores:Wt}=G(),_r=K(),yr=O(),z=new WeakMap,Se=new WeakMap,zt=i=>(Se.has(i)||Se.set(i,new pr({max:100})),Se.get(i));async function Dt(i=!1){fr(this,"jwks_uri");let e=Wt.get(this),t=zt(this);return i||!e?z.has(this)?z.get(this):(t.reset(),z.set(this,(async()=>{let r=await yr.call(this,{method:"GET",responseType:"json",url:this.jwks_uri,headers:{Accept:"application/json, application/jwk-set+json"}}).finally(()=>{z.delete(this)}),n=_r(r),o=lr.fromJWKS(n,{onlyPublic:!0});return t.set("throttle",!0,60*1e3),Wt.set(this,o),o})()),z.get(this)):e}async function wr({kid:i,kty:e,alg:t,use:r},{allowMulti:n=!1}={}){let o=zt(this),a={kid:i,kty:e,alg:t,use:r},s=hr(a,{algorithm:"sha256",ignoreUnknown:!0,unorderedArrays:!0,unorderedSets:!0}),u=o.get(s)||o.get("throttle"),c=await Dt.call(this,!u),d=c.all(a);if(delete a.use,d.length===0)throw new Jt({printf:["no valid key found in issuer's jwks_uri for key parameters %j",a],jwks:c});if(!n&&d.length>1&&!i)throw new Jt({printf:["multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",a],jwks:c});return o.set(s,!0),d}je.exports.queryKeyStore=wr;je.exports.keystore=Dt});var Bt=_((Oi,Ut)=>{var{inspect:Ht}=l("util"),{RPError:V,OPError:mr}=x(),Nt=$(),xe=class{#e;#t;#r;#i;#o;#a;#n;#c;#s;constructor({client:e,exchangeBody:t,clientAssertionPayload:r,response:n,maxAge:o,DPoP:a}){if(["verification_uri","user_code","device_code"].forEach(s=>{if(typeof n[s]!="string"||!n[s])throw new V(`expected ${s} string to be returned by Device Authorization Response, got %j`,n[s])}),!Number.isSafeInteger(n.expires_in))throw new V("expected expires_in number to be returned by Device Authorization Response, got %j",n.expires_in);this.#a=Nt()+n.expires_in,this.#t=e,this.#i=a,this.#c=o,this.#o=t,this.#r=r,this.#s=n,this.#n=n.interval*1e3||5e3}abort(){this.#e=!0}async poll({signal:e}={}){if(e&&e.aborted||this.#e)throw new V("polling aborted");if(this.expired())throw new V("the device code %j has expired and the device authorization session has concluded",this.device_code);await new Promise(r=>setTimeout(r,this.#n));let t;try{t=await this.#t.grant({...this.#o,grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:this.device_code},{clientAssertionPayload:this.#r,DPoP:this.#i})}catch(r){switch(r instanceof mr&&r.error){case"slow_down":this.#n+=5e3;case"authorization_pending":return this.poll({signal:e});default:throw r}}return"id_token"in t&&(await this.#t.decryptIdToken(t),await this.#t.validateIdToken(t,void 0,"token",this.#c)),t}get device_code(){return this.#s.device_code}get user_code(){return this.#s.user_code}get verification_uri(){return this.#s.verification_uri}get verification_uri_complete(){return this.#s.verification_uri_complete}get expires_in(){return Math.max.apply(null,[this.#a-Nt(),0])}expired(){return this.expires_in===0}[Ht.custom](){return`${this.constructor.name} ${Ht(this.#s,{depth:1/0,colors:__Process$.stdout.isTTY,compact:!1,sorted:!0})}`}};Ut.exports=xe});var Ke=_((Ci,Be)=>{var{inspect:Kt}=l("util"),gr=l("http"),Pe=l("crypto"),{strict:qe}=l("assert"),De=l("querystring"),He=l("url"),{URL:Mt,URLSearchParams:It}=l("url"),k=l("jose"),ve=l("oidc-token-hash"),ss=et(),br=rt(),Y=R(),Lt=de(),kr=he(),{assertSigningAlgValuesSupport:Ft,assertIssuerConfiguration:S}=N(),Ne=U(),v=C(),P=K(),b=le(),{OPError:Ae,RPError:h}=x(),Oe=$(),{random:Gt}=J(),Re=O(),{CLOCK_TOLERANCE:j}=I(),{keystores:Ce}=G(),Er=ge(),Vt=W(),{authenticatedPost:D,resolveResponseType:Sr,resolveRedirectUri:jr}=Ee(),{queryKeyStore:Yt}=Te(),Tr=Bt(),[Qt,xr]=__Process$.version.slice(1).split(".").map(i=>parseInt(i,10)),Pr=Qt>=17||Qt===16&&xr>=9,$e=Symbol(),Xt=Symbol(),Zt=Symbol();function q(i){return Ne(i,"access_token","code","error_description","error_uri","error","expires_in","id_token","iss","response","session_state","state","token_type")}function Je(i,e="Bearer"){return`${e} ${i}`}function We(i){let e=He.parse(i);return e.search?De.parse(e.search.substring(1)):{}}function qr(i,e,t){if(i[t]===void 0)throw new h({message:`missing required JWT property ${t}`,jwt:e})}function Q(i){let e={client_id:this.client_id,scope:"openid",response_type:Sr.call(this),redirect_uri:jr.call(this),...i};return Object.entries(e).forEach(([t,r])=>{r==null?delete e[t]:t==="claims"&&typeof r=="object"?e[t]=JSON.stringify(r):t==="resource"&&Array.isArray(r)?e[t]=r:typeof r!="string"&&(e[t]=String(r))}),e}function es(i){if(!v(i)||!Array.isArray(i.keys)||i.keys.some(e=>!v(e)||!("kty"in e)))throw new TypeError("jwks must be a JSON Web Key Set formatted object");return Er.fromJWKS(i,{onlyPrivate:!0})}function vr(i,e){try{let t=i.issuer.token_endpoint_auth_methods_supported;t.includes(e.token_endpoint_auth_method)||t.includes("client_secret_post")&&(e.token_endpoint_auth_method="client_secret_post")}catch{}}function Ar(i,e,t){if(e.token_endpoint_auth_method||vr(i,t),e.redirect_uri){if(e.redirect_uris)throw new TypeError("provide a redirect_uri or redirect_uris, not both");t.redirect_uris=[e.redirect_uri],delete t.redirect_uri}if(e.response_type){if(e.response_types)throw new TypeError("provide a response_type or response_types, not both");t.response_types=[e.response_type],delete t.response_type}}function Or(i,e,t){if(!e[`${i}_endpoint`])return;let r=t.token_endpoint_auth_method,n=t.token_endpoint_auth_signing_alg,o=`${i}_endpoint_auth_method`,a=`${i}_endpoint_auth_signing_alg`;t[o]===void 0&&t[a]===void 0&&(r!==void 0&&(t[o]=r),n!==void 0&&(t[a]=n))}var X=class{#e;#t;#r;#i;constructor(e,t,r={},n,o){if(this.#e=new Map,this.#t=e,this.#r=t,typeof r.client_id!="string"||!r.client_id)throw new TypeError("client_id is required");let a={grant_types:["authorization_code"],id_token_signed_response_alg:"RS256",authorization_signed_response_alg:"RS256",response_types:["code"],token_endpoint_auth_method:"client_secret_basic",...this.fapi()?{grant_types:["authorization_code","implicit"],id_token_signed_response_alg:"PS256",authorization_signed_response_alg:"PS256",response_types:["code id_token"],tls_client_certificate_bound_access_tokens:!0,token_endpoint_auth_method:void 0}:void 0,...r};if(this.fapi())switch(a.token_endpoint_auth_method){case"self_signed_tls_client_auth":case"tls_client_auth":break;case"private_key_jwt":if(!n)throw new TypeError("jwks is required");break;case void 0:throw new TypeError("token_endpoint_auth_method is required");default:throw new TypeError("invalid or unsupported token_endpoint_auth_method")}if(Ar(this,r,a),Ft("token",this.issuer,a),["introspection","revocation"].forEach(s=>{Or(s,this.issuer,a),Ft(s,this.issuer,a)}),Object.entries(a).forEach(([s,u])=>{this.#e.set(s,u),this[s]||Object.defineProperty(this,s,{get(){return this.#e.get(s)},enumerable:!0})}),n!==void 0){let s=es.call(this,n);Ce.set(this,s)}o!=null&&o.additionalAuthorizedParties&&(this.#i=Vt(o.additionalAuthorizedParties)),this[j]=0}authorizationUrl(e={}){if(!v(e))throw new TypeError("params must be a plain object");S(this.issuer,"authorization_endpoint");let t=new Mt(this.issuer.authorization_endpoint);for(let[r,n]of Object.entries(Q.call(this,e)))if(Array.isArray(n)){t.searchParams.delete(r);for(let o of n)t.searchParams.append(r,o)}else t.searchParams.set(r,n);return t.href.replace(/\+/g,"%20")}authorizationPost(e={}){if(!v(e))throw new TypeError("params must be a plain object");let t=Q.call(this,e),r=Object.keys(t).map(n=>`<input type="hidden" name="${n}" value="${t[n]}"/>`).join(`
`);return`<!DOCTYPE html>
<head>
<title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
<form method="post" action="${this.issuer.authorization_endpoint}">
  ${r}
</form>
</body>
</html>`}endSessionUrl(e={}){S(this.issuer,"end_session_endpoint");let{0:t,length:r}=this.post_logout_redirect_uris||[],{post_logout_redirect_uri:n=r===1?t:void 0}=e,o;if({id_token_hint:o,...e}=e,o instanceof b){if(!o.id_token)throw new TypeError("id_token not present in TokenSet");o=o.id_token}let a=He.parse(this.issuer.end_session_endpoint),s=Lt(We(this.issuer.end_session_endpoint),e,{post_logout_redirect_uri:n,client_id:this.client_id},{id_token_hint:o});return Object.entries(s).forEach(([u,c])=>{c==null&&delete s[u]}),a.search=null,a.query=s,He.format(a)}callbackParams(e){let t=e instanceof gr.IncomingMessage||e&&e.method&&e.url;if(!(typeof e=="string")&&!t)throw new TypeError("#callbackParams only accepts string urls, http.IncomingMessage or a lookalike");if(t)switch(e.method){case"GET":return q(We(e.url));case"POST":if(e.body===void 0)throw new TypeError("incoming message body missing, include a body parser prior to this method call");switch(typeof e.body){case"object":case"string":return __Buffer$.isBuffer(e.body)?q(De.parse(e.body.toString("utf-8"))):typeof e.body=="string"?q(De.parse(e.body)):q(e.body);default:throw new TypeError("invalid IncomingMessage body object")}default:throw new TypeError("invalid IncomingMessage method")}else return q(We(e))}async callback(e,t,r={},{exchangeBody:n,clientAssertionPayload:o,DPoP:a}={}){let s=q(t);if(r.jarm&&!("response"in t))throw new h({message:"expected a JARM response",checks:r,params:s});if("response"in t){let c=await this.decryptJARM(s.response);s=await this.validateJARM(c)}if(this.default_max_age&&!r.max_age&&(r.max_age=this.default_max_age),s.state&&!r.state)throw new TypeError("checks.state argument is missing");if(!s.state&&r.state)throw new h({message:"state missing from the response",checks:r,params:s});if(r.state!==s.state)throw new h({printf:["state mismatch, expected %s, got: %s",r.state,s.state],checks:r,params:s});if("iss"in s){if(S(this.issuer,"issuer"),s.iss!==this.issuer.issuer)throw new h({printf:["iss mismatch, expected %s, got: %s",this.issuer.issuer,s.iss],params:s})}else if(this.issuer.authorization_response_iss_parameter_supported&&!("id_token"in s)&&!("response"in t))throw new h({message:"iss missing from the response",params:s});if(s.error)throw new Ae(s);let u={code:["code"],id_token:["id_token"],token:["access_token","token_type"]};if(r.response_type){for(let c of r.response_type.split(" "))if(c==="none"){if(s.code||s.id_token||s.access_token)throw new h({message:'unexpected params encountered for "none" response',checks:r,params:s})}else for(let d of u[c])if(!s[d])throw new h({message:`${d} missing from response`,checks:r,params:s})}if(s.id_token){let c=new b(s);if(await this.decryptIdToken(c),await this.validateIdToken(c,r.nonce,"authorization",r.max_age,r.state),!s.code)return c}if(s.code){let c=await this.grant({...n,grant_type:"authorization_code",code:s.code,redirect_uri:e,code_verifier:r.code_verifier},{clientAssertionPayload:o,DPoP:a});return await this.decryptIdToken(c),await this.validateIdToken(c,r.nonce,"token",r.max_age),s.session_state&&(c.session_state=s.session_state),c}return new b(s)}async oauthCallback(e,t,r={},{exchangeBody:n,clientAssertionPayload:o,DPoP:a}={}){let s=q(t);if(r.jarm&&!("response"in t))throw new h({message:"expected a JARM response",checks:r,params:s});if("response"in t){let c=await this.decryptJARM(s.response);s=await this.validateJARM(c)}if(s.state&&!r.state)throw new TypeError("checks.state argument is missing");if(!s.state&&r.state)throw new h({message:"state missing from the response",checks:r,params:s});if(r.state!==s.state)throw new h({printf:["state mismatch, expected %s, got: %s",r.state,s.state],checks:r,params:s});if("iss"in s){if(S(this.issuer,"issuer"),s.iss!==this.issuer.issuer)throw new h({printf:["iss mismatch, expected %s, got: %s",this.issuer.issuer,s.iss],params:s})}else if(this.issuer.authorization_response_iss_parameter_supported&&!("id_token"in s)&&!("response"in t))throw new h({message:"iss missing from the response",params:s});if(s.error)throw new Ae(s);if(typeof s.id_token=="string"&&s.id_token.length)throw new h({message:"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()",params:s});delete s.id_token;let u={code:["code"],token:["access_token","token_type"]};if(r.response_type)for(let c of r.response_type.split(" ")){if(c==="none"&&(s.code||s.id_token||s.access_token))throw new h({message:'unexpected params encountered for "none" response',checks:r,params:s});if(u[c]){for(let d of u[c])if(!s[d])throw new h({message:`${d} missing from response`,checks:r,params:s})}}if(s.code){let c=await this.grant({...n,grant_type:"authorization_code",code:s.code,redirect_uri:e,code_verifier:r.code_verifier},{clientAssertionPayload:o,DPoP:a});if(typeof c.id_token=="string"&&c.id_token.length)throw new h({message:"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()",params:s});return delete c.id_token,c}return new b(s)}async decryptIdToken(e){if(!this.id_token_encrypted_response_alg)return e;let t=e;if(t instanceof b){if(!t.id_token)throw new TypeError("id_token not present in TokenSet");t=t.id_token}let r=this.id_token_encrypted_response_alg,n=this.id_token_encrypted_response_enc,o=await this.decryptJWE(t,r,n);return e instanceof b?(e.id_token=o,e):o}async validateJWTUserinfo(e){let t=this.userinfo_signed_response_alg;return this.validateJWT(e,t,[])}async decryptJARM(e){if(!this.authorization_encrypted_response_alg)return e;let t=this.authorization_encrypted_response_alg,r=this.authorization_encrypted_response_enc;return this.decryptJWE(e,t,r)}async decryptJWTUserinfo(e){if(!this.userinfo_encrypted_response_alg)return e;let t=this.userinfo_encrypted_response_alg,r=this.userinfo_encrypted_response_enc;return this.decryptJWE(e,t,r)}async decryptJWE(e,t,r="A128CBC-HS256"){let n=JSON.parse(Y.decode(e.split(".")[0]));if(n.alg!==t)throw new h({printf:["unexpected JWE alg received, expected %s, got: %s",t,n.alg],jwt:e});if(n.enc!==r)throw new h({printf:["unexpected JWE enc received, expected %s, got: %s",r,n.enc],jwt:e});let o=s=>new TextDecoder().decode(s.plaintext),a;if(t.match(/^(?:RSA|ECDH)/)){let s=await Ce.get(this),u=k.decodeProtectedHeader(e);for(let c of s.all({...u,use:"enc"}))if(a=await k.compactDecrypt(e,await c.keyObject(u.alg)).then(o,()=>{}),a)break}else a=await k.compactDecrypt(e,this.secretForAlg(t==="dir"?r:t)).then(o,()=>{});if(!a)throw new h({message:"failed to decrypt JWE",jwt:e});return a}async validateIdToken(e,t,r,n,o){let a=e,s=this.id_token_signed_response_alg;if(a instanceof b){if(!a.id_token)throw new TypeError("id_token not present in TokenSet");a=a.id_token}a=String(a);let c=Oe(),{protected:d,payload:p,key:f}=await this.validateJWT(a,s);if(typeof n=="number"||n!==Zt&&this.require_auth_time){if(!p.auth_time)throw new h({message:"missing required JWT property auth_time",jwt:a});if(typeof p.auth_time!="number")throw new h({message:"JWT auth_time claim must be a JSON numeric value",jwt:a})}if(typeof n=="number"&&p.auth_time+n<c-this[j])throw new h({printf:["too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i",n,p.auth_time,c-this[j]],now:c,tolerance:this[j],auth_time:p.auth_time,jwt:a});if(t!==Xt&&(p.nonce||t!==void 0)&&p.nonce!==t)throw new h({printf:["nonce mismatch, expected %s, got: %s",t,p.nonce],jwt:a});if(r==="authorization"){if(!p.at_hash&&e.access_token)throw new h({message:"missing required property at_hash",jwt:a});if(!p.c_hash&&e.code)throw new h({message:"missing required property c_hash",jwt:a});if(this.fapi()&&!p.s_hash&&(e.state||o))throw new h({message:"missing required property s_hash",jwt:a});if(p.s_hash){if(!o)throw new TypeError('cannot verify s_hash, "checks.state" property not provided');try{ve.validate({claim:"s_hash",source:"state"},p.s_hash,o,d.alg,f.jwk&&f.jwk.crv)}catch(y){throw new h({message:y.message,jwt:a})}}}if(this.fapi()&&p.iat<c-3600)throw new h({printf:["JWT issued too far in the past, now %i, iat %i",c,p.iat],now:c,tolerance:this[j],iat:p.iat,jwt:a});if(e.access_token&&p.at_hash!==void 0)try{ve.validate({claim:"at_hash",source:"access_token"},p.at_hash,e.access_token,d.alg,f.jwk&&f.jwk.crv)}catch(y){throw new h({message:y.message,jwt:a})}if(e.code&&p.c_hash!==void 0)try{ve.validate({claim:"c_hash",source:"code"},p.c_hash,e.code,d.alg,f.jwk&&f.jwk.crv)}catch(y){throw new h({message:y.message,jwt:a})}return e}async validateJWT(e,t,r=["iss","sub","aud","exp","iat"]){let n=this.issuer.issuer==="https://self-issued.me",o=Oe(),a,s;try{({header:a,payload:s}=br(e,{complete:!0}))}catch(c){throw new h({printf:["failed to decode JWT (%s: %s)",c.name,c.message],jwt:e})}if(a.alg!==t)throw new h({printf:["unexpected JWT alg received, expected %s, got: %s",t,a.alg],jwt:e});if(n&&(r=[...r,"sub_jwk"]),r.forEach(qr.bind(void 0,s,e)),s.iss!==void 0){let c=this.issuer.issuer;if(this.#r&&(c=this.issuer.issuer.replace("{tenantid}",s.tid)),s.iss!==c)throw new h({printf:["unexpected iss value, expected %s, got: %s",c,s.iss],jwt:e})}if(s.iat!==void 0&&typeof s.iat!="number")throw new h({message:"JWT iat claim must be a JSON numeric value",jwt:e});if(s.nbf!==void 0){if(typeof s.nbf!="number")throw new h({message:"JWT nbf claim must be a JSON numeric value",jwt:e});if(s.nbf>o+this[j])throw new h({printf:["JWT not active yet, now %i, nbf %i",o+this[j],s.nbf],now:o,tolerance:this[j],nbf:s.nbf,jwt:e})}if(s.exp!==void 0){if(typeof s.exp!="number")throw new h({message:"JWT exp claim must be a JSON numeric value",jwt:e});if(o-this[j]>=s.exp)throw new h({printf:["JWT expired, now %i, exp %i",o-this[j],s.exp],now:o,tolerance:this[j],exp:s.exp,jwt:e})}if(s.aud!==void 0){if(Array.isArray(s.aud)){if(s.aud.length>1&&!s.azp)throw new h({message:"missing required JWT property azp",jwt:e});if(!s.aud.includes(this.client_id))throw new h({printf:["aud is missing the client_id, expected %s to be included in %j",this.client_id,s.aud],jwt:e})}else if(s.aud!==this.client_id)throw new h({printf:["aud mismatch, expected %s, got: %s",this.client_id,s.aud],jwt:e})}if(s.azp!==void 0){let c=this.#i;if(typeof c=="string"?c=[this.client_id,c]:Array.isArray(c)?c=[this.client_id,...c]:c=[this.client_id],!c.includes(s.azp))throw new h({printf:["azp mismatch, got: %s",s.azp],jwt:e})}let u;if(n){try{qe(v(s.sub_jwk));let c=await k.importJWK(s.sub_jwk,a.alg);qe.equal(c.type,"public"),u=[{keyObject(){return c}}]}catch{throw new h({message:"failed to use sub_jwk claim as an asymmetric JSON Web Key",jwt:e})}if(await k.calculateJwkThumbprint(s.sub_jwk)!==s.sub)throw new h({message:"failed to match the subject with sub_jwk",jwt:e})}else a.alg.startsWith("HS")?u=[this.secretForAlg(a.alg)]:a.alg!=="none"&&(u=await Yt.call(this.issuer,{...a,use:"sig"}));if(!u&&a.alg==="none")return{protected:a,payload:s};for(let c of u){let d=await k.compactVerify(e,c instanceof Uint8Array?c:await c.keyObject(a.alg)).catch(()=>{});if(d)return{payload:s,protected:d.protectedHeader,key:c}}throw new h({message:"failed to validate JWT signature",jwt:e})}async refresh(e,{exchangeBody:t,clientAssertionPayload:r,DPoP:n}={}){let o=e;if(o instanceof b){if(!o.refresh_token)throw new TypeError("refresh_token not present in TokenSet");o=o.refresh_token}let a=await this.grant({...t,grant_type:"refresh_token",refresh_token:String(o)},{clientAssertionPayload:r,DPoP:n});if(a.id_token&&(await this.decryptIdToken(a),await this.validateIdToken(a,Xt,"token",Zt),e instanceof b&&e.id_token)){let s=e.claims().sub,u=a.claims().sub;if(u!==s)throw new h({printf:["sub mismatch, expected %s, got: %s",s,u],jwt:a.id_token})}return a}async requestResource(e,t,{method:r,headers:n,body:o,DPoP:a,tokenType:s=a?"DPoP":t instanceof b?t.token_type:"Bearer"}={},u){if(t instanceof b){if(!t.access_token)throw new TypeError("access_token not present in TokenSet");t=t.access_token}if(t){if(typeof t!="string")throw new TypeError("invalid access token provided")}else throw new TypeError("no access token provided");let c={headers:{Authorization:Je(t,s),...n},body:o},d=!!this.tls_client_certificate_bound_access_tokens,p=await Re.call(this,{...c,responseType:"buffer",method:r,url:e},{accessToken:t,mTLS:d,DPoP:a}),f=p.headers["www-authenticate"];return u!==$e&&f&&f.toLowerCase().startsWith("dpop ")&&kr(f).error==="use_dpop_nonce"?this.requestResource(e,t,{method:r,headers:n,body:o,DPoP:a,tokenType:s}):p}async userinfo(e,{method:t="GET",via:r="header",tokenType:n,params:o,DPoP:a}={}){S(this.issuer,"userinfo_endpoint");let s={tokenType:n,method:String(t).toUpperCase(),DPoP:a};if(s.method!=="GET"&&s.method!=="POST")throw new TypeError("#userinfo() method can only be POST or a GET");if(r==="body"&&s.method!=="POST")throw new TypeError("can only send body on POST");let u=!!(this.userinfo_signed_response_alg||this.userinfo_encrypted_response_alg);u?s.headers={Accept:"application/jwt"}:s.headers={Accept:"application/json"};let c=!!this.tls_client_certificate_bound_access_tokens,d;c&&this.issuer.mtls_endpoint_aliases&&(d=this.issuer.mtls_endpoint_aliases.userinfo_endpoint),d=new Mt(d||this.issuer.userinfo_endpoint),r==="body"&&(s.headers.Authorization=void 0,s.headers["Content-Type"]="application/x-www-form-urlencoded",s.body=new It,s.body.append("access_token",e instanceof b?e.access_token:e)),o&&(s.method==="GET"?Object.entries(o).forEach(([y,w])=>{d.searchParams.append(y,w)}):s.body?Object.entries(o).forEach(([y,w])=>{s.body.append(y,w)}):(s.body=new It,s.headers["Content-Type"]="application/x-www-form-urlencoded",Object.entries(o).forEach(([y,w])=>{s.body.append(y,w)}))),s.body&&(s.body=s.body.toString());let p=await this.requestResource(d,e,s),f=P(p,{bearer:!0});if(u){if(!/^application\/jwt/.test(p.headers["content-type"]))throw new h({message:"expected application/jwt response from the userinfo_endpoint",response:p});let y=p.body.toString(),w=await this.decryptJWTUserinfo(y);if(this.userinfo_signed_response_alg)({payload:f}=await this.validateJWTUserinfo(w));else try{f=JSON.parse(w),qe(v(f))}catch{throw new h({message:"failed to parse userinfo JWE payload as JSON",jwt:w})}}else try{f=JSON.parse(p.body)}catch(y){throw Object.defineProperty(y,"response",{value:p}),y}if(e instanceof b&&e.id_token){let y=e.claims().sub;if(f.sub!==y)throw new h({printf:["userinfo sub mismatch, expected %s, got: %s",y,f.sub],body:f,jwt:e.id_token})}return f}encryptionSecret(e){let t=e<=256?"sha256":e<=384?"sha384":e<=512?"sha512":!1;if(!t)throw new Error("unsupported symmetric encryption key derivation");return Pe.createHash(t).update(this.client_secret).digest().slice(0,e/8)}secretForAlg(e){if(!this.client_secret)throw new TypeError("client_secret is required");return/^A(\d{3})(?:GCM)?KW$/.test(e)?this.encryptionSecret(parseInt(RegExp.$1,10)):/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(e)?this.encryptionSecret(parseInt(RegExp.$2||RegExp.$1,10)):new TextEncoder().encode(this.client_secret)}async grant(e,{clientAssertionPayload:t,DPoP:r}={},n){S(this.issuer,"token_endpoint");let o=await D.call(this,"token",{form:e,responseType:"json"},{clientAssertionPayload:t,DPoP:r}),a;try{a=P(o)}catch(s){if(n!==$e&&s instanceof Ae&&s.error==="use_dpop_nonce")return this.grant(e,{clientAssertionPayload:t,DPoP:r},$e);throw s}return new b(a)}async deviceAuthorization(e={},{exchangeBody:t,clientAssertionPayload:r,DPoP:n}={}){S(this.issuer,"device_authorization_endpoint"),S(this.issuer,"token_endpoint");let o=Q.call(this,{client_id:this.client_id,redirect_uri:null,response_type:null,...e}),a=await D.call(this,"device_authorization",{responseType:"json",form:o},{clientAssertionPayload:r,endpointAuthMethod:"token"}),s=P(a);return new Tr({client:this,exchangeBody:t,clientAssertionPayload:r,response:s,maxAge:e.max_age,DPoP:n})}async revoke(e,t,{revokeBody:r,clientAssertionPayload:n}={}){if(S(this.issuer,"revocation_endpoint"),t!==void 0&&typeof t!="string")throw new TypeError("hint must be a string");let o={...r,token:e};t&&(o.token_type_hint=t);let a=await D.call(this,"revocation",{form:o},{clientAssertionPayload:n});P(a,{body:!1})}async introspect(e,t,{introspectBody:r,clientAssertionPayload:n}={}){if(S(this.issuer,"introspection_endpoint"),t!==void 0&&typeof t!="string")throw new TypeError("hint must be a string");let o={...r,token:e};t&&(o.token_type_hint=t);let a=await D.call(this,"introspection",{form:o,responseType:"json"},{clientAssertionPayload:n});return P(a)}static async register(e,t={}){let{initialAccessToken:r,jwks:n,...o}=t;if(S(this.issuer,"registration_endpoint"),n!==void 0&&!(e.jwks||e.jwks_uri)){let u=await es.call(this,n);e.jwks=u.toJWKS()}let a=await Re.call(this,{headers:{Accept:"application/json",...r?{Authorization:Je(r)}:void 0},responseType:"json",json:e,url:this.issuer.registration_endpoint,method:"POST"}),s=P(a,{statusCode:201,bearer:!0});return new this(s,n,o)}get metadata(){return Vt(Object.fromEntries(this.#e.entries()))}static async fromUri(e,t,r,n){let o=await Re.call(this,{method:"GET",url:e,responseType:"json",headers:{Authorization:Je(t),Accept:"application/json"}}),a=P(o,{bearer:!0});return new this(a,r,n)}async requestObject(e={},{sign:t=this.request_object_signing_alg||"none",encrypt:{alg:r=this.request_object_encryption_alg,enc:n=this.request_object_encryption_enc||"A128CBC-HS256"}={}}={}){if(!v(e))throw new TypeError("requestObject must be a plain object");let o,a,s=Oe(),u={alg:t,typ:"oauth-authz-req+jwt"},c=JSON.stringify(Lt({},e,{iss:this.client_id,aud:this.issuer.issuer,client_id:this.client_id,jti:Gt(),iat:s,exp:s+300,...this.fapi()?{nbf:s}:void 0}));if(t==="none")o=[Y.encode(JSON.stringify(u)),Y.encode(c),""].join(".");else{let p=t.startsWith("HS");if(p)a=this.secretForAlg(t);else{let f=await Ce.get(this);if(!f)throw new TypeError(`no keystore present for client, cannot sign using alg ${t}`);if(a=f.get({alg:t,use:"sig"}),!a)throw new TypeError(`no key to sign with found for alg ${t}`)}o=await new k.CompactSign(new TextEncoder().encode(c)).setProtectedHeader({...u,kid:p?void 0:a.jwk.kid}).sign(p?a:await a.keyObject(t))}if(!r)return o;let d={alg:r,enc:n,cty:"oauth-authz-req+jwt"};return d.alg.match(/^(RSA|ECDH)/)?[a]=await Yt.call(this.issuer,{alg:d.alg,use:"enc"},{allowMulti:!0}):a=this.secretForAlg(d.alg==="dir"?d.enc:d.alg),new k.CompactEncrypt(new TextEncoder().encode(o)).setProtectedHeader({...d,kid:a instanceof Uint8Array?void 0:a.jwk.kid}).encrypt(a instanceof Uint8Array?a:await a.keyObject(d.alg))}async pushedAuthorizationRequest(e={},{clientAssertionPayload:t}={}){S(this.issuer,"pushed_authorization_request_endpoint");let r={..."request"in e?e:Q.call(this,e),client_id:this.client_id},n=await D.call(this,"pushed_authorization_request",{responseType:"json",form:r},{clientAssertionPayload:t,endpointAuthMethod:"token"}),o=P(n,{statusCode:201});if(!("expires_in"in o))throw new h({message:"expected expires_in in Pushed Authorization Successful Response",response:n});if(typeof o.expires_in!="number")throw new h({message:"invalid expires_in value in Pushed Authorization Successful Response",response:n});if(!("request_uri"in o))throw new h({message:"expected request_uri in Pushed Authorization Successful Response",response:n});if(typeof o.request_uri!="string")throw new h({message:"invalid request_uri value in Pushed Authorization Successful Response",response:n});return o}get issuer(){return this.#t}[Kt.custom](){return`${this.constructor.name} ${Kt(this.metadata,{depth:1/0,colors:__Process$.stdout.isTTY,compact:!1,sorted:!0})}`}fapi(){return this.constructor.name==="FAPI1Client"}async validateJARM(e){let t=this.authorization_signed_response_alg,{payload:r}=await this.validateJWT(e,t,["iss","exp","aud"]);return q(r)}async dpopProof(e,t,r){if(!v(e))throw new TypeError("payload must be a plain object");let n;if(ss(t))n=t;else if(t[Symbol.toStringTag]==="CryptoKey")n=t;else if(k.cryptoRuntime==="node:crypto")n=Pe.createPrivateKey(t);else throw new TypeError("unrecognized crypto runtime");if(n.type!=="private")throw new TypeError('"DPoP" option must be a private key');let o=Ue.call(this,n,t);if(!o)throw new TypeError("could not determine DPoP JWS Algorithm");return new k.SignJWT({ath:r?Y.encode(Pe.createHash("sha256").update(r).digest()):void 0,...e}).setProtectedHeader({alg:o,typ:"dpop+jwt",jwk:await Rr(n,t)}).setIssuedAt().setJti(Gt()).sign(n)}};function ts(i){switch(i.algorithm.name){case"Ed25519":case"Ed448":return"EdDSA";case"ECDSA":{switch(i.algorithm.namedCurve){case"P-256":return"ES256";case"P-384":return"ES384";case"P-521":return"ES512";default:break}break}case"RSASSA-PKCS1-v1_5":return`RS${i.algorithm.hash.name.slice(4)}`;case"RSA-PSS":return`PS${i.algorithm.hash.name.slice(4)}`;default:throw new TypeError("unsupported DPoP private key")}}var Ue;if(k.cryptoRuntime==="node:crypto"){let e=function(s,u,c){if(typeof u=="object"&&u.format==="jwk"&&u.key&&u.key.alg)return u.key.alg;if(Array.isArray(c)){let d=c.filter(RegExp.prototype.test.bind(i));return s.asymmetricKeyType==="rsa-pss"&&(d=d.filter(p=>p.startsWith("PS"))),["PS256","PS384","PS512","RS256","RS384","RS384"].find(p=>d.includes(p))}return"PS256"},a=function(s,u){switch(typeof u=="object"&&typeof u.key=="object"&&u.key.crv){case"P-256":return"ES256";case"secp256k1":return"ES256K";case"P-384":return"ES384";case"P-512":return"ES512";default:break}let c=s.export({format:"der",type:"pkcs8"}),d=c[1]<128?17:18,p=c[d],f=c.slice(d+1,d+1+p);if(f.equals(t))return"ES256";if(f.equals(r))return"ES384";if(f.equals(n))return"ES512";if(f.equals(o))return"ES256K";throw new TypeError("unsupported DPoP private key curve")};Cr=e,$r=a,Ue=function(s,u){if(u[Symbol.toStringTag]==="CryptoKey")return ts(s);switch(s.asymmetricKeyType){case"ed25519":case"ed448":return"EdDSA";case"ec":return a(s,u);case"rsa":case(Pr&&"rsa-pss"):return e(s,u,this.issuer.dpop_signing_alg_values_supported);default:throw new TypeError("unsupported DPoP private key")}};let i=/^(?:RS|PS)(?:256|384|512)$/,t=__Buffer$.from([42,134,72,206,61,3,1,7]),r=__Buffer$.from([43,129,4,0,34]),n=__Buffer$.from([43,129,4,0,35]),o=__Buffer$.from([43,129,4,0,10])}else Ue=ts;var Cr,$r,ze=new WeakMap;async function Rr(i,e){if(k.cryptoRuntime==="node:crypto"&&typeof e=="object"&&typeof e.key=="object"&&e.format==="jwk")return Ne(e.key,"kty","crv","x","y","e","n");if(ze.has(e))return ze.get(e);let t=Ne(await k.exportJWK(i),"kty","crv","x","y","e","n");return(ss(e)||k.cryptoRuntime==="WebCryptoAPI")&&ze.set(e,t),t}Be.exports=(i,e=!1)=>class extends X{constructor(...r){super(i,e,...r)}static get issuer(){return i}};Be.exports.BaseClient=X});var is=_(($i,rs)=>{var Jr=l("lru-cache");rs.exports=new Jr({max:100})});var os=_((Ji,ns)=>{var Wr=/^\d+$/;function zr(i){if(i.includes("://"))return!0;let e=i.replace(/(\/|\?)/g,"#").split("#")[0];if(e.includes(":")){let t=e.indexOf(":"),r=e.slice(t+1);if(!Wr.test(r))return!0}return!1}function Dr(i){if(!i.includes("@"))return!1;let e=i.split("@"),t=e[e.length-1];return!(t.includes(":")||t.includes("/")||t.includes("?"))}function Hr(i){if(typeof i!="string")throw new TypeError("input must be a string");let e;return zr(i)?e=i:Dr(i)?e=`acct:${i}`:e=`https://${i}`,e.split("#")[0]}ns.exports=Hr});var hs=_((zi,ds)=>{var{inspect:as}=l("util"),Me=l("url"),{RPError:Ie}=x(),Nr=Ke(),Z=is(),Le=K(),Ur=os(),Fe=O(),Br=W(),{keystore:Kr}=Te(),cs=["https://login.microsoftonline.com/common/.well-known/openid-configuration","https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration","https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration","https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration"],ee=Symbol(),us={claim_types_supported:["normal"],claims_parameter_supported:!1,grant_types_supported:["authorization_code","implicit"],request_parameter_supported:!1,request_uri_parameter_supported:!0,require_request_uri_registration:!1,response_modes_supported:["query","fragment"],token_endpoint_auth_methods_supported:["client_secret_basic"]},Ge=class i{#e;constructor(e={}){let t=e[ee];delete e[ee],["introspection","revocation"].forEach(n=>{e[`${n}_endpoint`]&&e[`${n}_endpoint_auth_methods_supported`]===void 0&&e[`${n}_endpoint_auth_signing_alg_values_supported`]===void 0&&(e.token_endpoint_auth_methods_supported&&(e[`${n}_endpoint_auth_methods_supported`]=e.token_endpoint_auth_methods_supported),e.token_endpoint_auth_signing_alg_values_supported&&(e[`${n}_endpoint_auth_signing_alg_values_supported`]=e.token_endpoint_auth_signing_alg_values_supported))}),this.#e=new Map,Object.entries(e).forEach(([n,o])=>{this.#e.set(n,o),this[n]||Object.defineProperty(this,n,{get(){return this.#e.get(n)},enumerable:!0})}),Z.set(this.issuer,this);let r=Nr(this,t);Object.defineProperties(this,{Client:{value:r,enumerable:!0},FAPI1Client:{value:class extends r{},enumerable:!0}})}get metadata(){return Br(Object.fromEntries(this.#e.entries()))}static async webfinger(e){let t=Ur(e),{host:r}=Me.parse(t),n=`https://${r}/.well-known/webfinger`,o=await Fe.call(this,{method:"GET",url:n,responseType:"json",searchParams:{resource:t,rel:"http://openid.net/specs/connect/1.0/issuer"},headers:{Accept:"application/json"}}),a=Le(o),s=Array.isArray(a.links)&&a.links.find(d=>typeof d=="object"&&d.rel==="http://openid.net/specs/connect/1.0/issuer"&&d.href);if(!s)throw new Ie({message:"no issuer found in webfinger response",body:a});if(typeof s.href!="string"||!s.href.startsWith("https://"))throw new Ie({printf:["invalid issuer location %s",s.href],body:a});let u=s.href;if(Z.has(u))return Z.get(u);let c=await this.discover(u);if(c.issuer!==u)throw Z.del(c.issuer),new Ie("discovered issuer mismatch, expected %s, got: %s",u,c.issuer);return c}static async discover(e){let t=Me.parse(e);if(t.pathname.includes("/.well-known/")){let s=await Fe.call(this,{method:"GET",responseType:"json",url:e,headers:{Accept:"application/json"}}),u=Le(s);return new i({...us,...u,[ee]:!!cs.find(c=>e.startsWith(c))})}let r;t.pathname.endsWith("/")?r=`${t.pathname}.well-known/openid-configuration`:r=`${t.pathname}/.well-known/openid-configuration`;let n=Me.format({...t,pathname:r}),o=await Fe.call(this,{method:"GET",responseType:"json",url:n,headers:{Accept:"application/json"}}),a=Le(o);return new i({...us,...a,[ee]:!!cs.find(s=>n.startsWith(s))})}async reloadJwksUri(){await Kr.call(this,!0)}[as.custom](){return`${this.constructor.name} ${as(this.metadata,{depth:1/0,colors:__Process$.stdout.isTTY,compact:!1,sorted:!0})}`}};ds.exports=Ge});var ws=_((Di,ys)=>{var ps=l("url"),{format:Mr}=l("util"),fs=W(),{RPError:ls,OPError:Ir}=x(),{BaseClient:Lr}=Ke(),{random:Ve,codeChallenge:Fr}=J(),Gr=U(),{resolveResponseType:Vr,resolveRedirectUri:Yr}=Ee();function Qr(i,e,t={}){i?this.error(i):e?this.success(e,t):this.fail(t)}function _s({client:i,params:e={},passReqToCallback:t=!1,sessionKey:r,usePKCE:n=!0,extras:o={}}={},a){if(!(i instanceof Lr))throw new TypeError("client must be an instance of openid-client Client");if(typeof a!="function")throw new TypeError("verify callback must be a function");if(!i.issuer||!i.issuer.issuer)throw new TypeError("client must have an issuer with an identifier");if(this._client=i,this._issuer=i.issuer,this._verify=a,this._passReqToCallback=t,this._usePKCE=n,this._key=r||`oidc:${ps.parse(this._issuer.issuer).hostname}`,this._params=fs(e),delete this._params.state,delete this._params.nonce,this._extras=fs(o),this._params.response_type||(this._params.response_type=Vr.call(i)),this._params.redirect_uri||(this._params.redirect_uri=Yr.call(i)),this._params.scope||(this._params.scope="openid"),this._usePKCE===!0){let s=Array.isArray(this._issuer.code_challenge_methods_supported)?this._issuer.code_challenge_methods_supported:!1;if(s&&s.includes("S256"))this._usePKCE="S256";else if(s&&s.includes("plain"))this._usePKCE="plain";else{if(s)throw new TypeError("neither code_challenge_method supported by the client is supported by the issuer");this._usePKCE="S256"}}else if(typeof this._usePKCE=="string"&&!["plain","S256"].includes(this._usePKCE))throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);this.name=ps.parse(i.issuer.issuer).hostname}_s.prototype.authenticate=function(e,t){(async()=>{let r=this._client;if(!e.session)throw new TypeError("authentication requires session support");let n=r.callbackParams(e),o=this._key,{0:a,length:s}=Object.keys(n);if(s===0||s===1&&a==="iss"){let E={state:Ve(),...this._params,...t};if(!E.nonce&&E.response_type.includes("id_token")&&(E.nonce=Ve()),e.session[o]=Gr(E,"nonce","state","max_age","response_type"),this._usePKCE&&E.response_type.includes("code")){let se=Ve();switch(e.session[o].code_verifier=se,this._usePKCE){case"S256":E.code_challenge=Fr(se),E.code_challenge_method="S256";break;case"plain":E.code_challenge=se;break}}this.redirect(r.authorizationUrl(E));return}let u=e.session[o];if(Object.keys(u||{}).length===0)throw new Error(Mr('did not find expected authorization request details in session, req.session["%s"] is %j',o,u));let{state:c,nonce:d,max_age:p,code_verifier:f,response_type:y}=u;try{delete e.session[o]}catch{}let w={redirect_uri:this._params.redirect_uri,...t},T={state:c,nonce:d,max_age:p,code_verifier:f,response_type:y},m=await r.callback(w.redirect_uri,n,T,this._extras),g=this._passReqToCallback,H=this._verify.length>(g?3:2)&&r.issuer.userinfo_endpoint,te=[m,Qr.bind(this)];if(H){if(!m.access_token)throw new ls({message:"expected access_token to be returned when asking for userinfo in verify callback",tokenset:m});let E=await r.userinfo(m);te.splice(1,0,E)}g&&te.unshift(e),this._verify(...te)})().catch(r=>{r instanceof Ir&&r.error!=="server_error"&&!r.error.startsWith("invalid")||r instanceof ls?this.fail(r):this.error(r)})};ys.exports=_s});var gs=_((Hi,ms)=>{var Xr=hs(),{OPError:Zr,RPError:ei}=x(),ti=ws(),si=le(),{CLOCK_TOLERANCE:ri,HTTP_OPTIONS:ii}=I(),ni=J(),{setDefaults:oi}=O();ms.exports={Issuer:Xr,Strategy:ti,TokenSet:si,errors:{OPError:Zr,RPError:ei},custom:{setHttpOptionsDefaults:oi,http_options:ii,clock_tolerance:ri},generators:ni}});var A=xs(gs(),1),Ni=A.default,Ui=A.default.Issuer,Bi=A.default.Strategy,Ki=A.default.TokenSet,Mi=A.default.errors,Ii=A.default.custom,Li=A.default.generators;export{Ui as Issuer,Bi as Strategy,Ki as TokenSet,Ii as custom,Ni as default,Mi as errors,Li as generators};
//# sourceMappingURL=openid-client.mjs.map