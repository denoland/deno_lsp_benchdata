/* esm.sh - esbuild bundle(@octokit/webhooks-methods@4.0.0) denonext production */
import{createHmac as p}from"node:crypto";var i=(r=>(r.SHA1="sha1",r.SHA256="sha256",r))(i||{});var f="4.0.0";async function m(r,e){let{secret:o,algorithm:t}=typeof r=="object"?{secret:r.secret,algorithm:r.algorithm||i.SHA256}:{secret:r,algorithm:i.SHA256};if(!o||!e)throw new TypeError("[@octokit/webhooks-methods] secret & payload required for sign()");if(!Object.values(i).includes(t))throw new TypeError(`[@octokit/webhooks] Algorithm ${t} is not supported. Must be  'sha1' or 'sha256'`);return`${t}=${p(t,o).update(e).digest("hex")}`}m.VERSION=f;import{timingSafeEqual as g}from"node:crypto";import{Buffer as u}from"node:buffer";var h=r=>r.startsWith("sha256=")?"sha256":"sha1";async function n(r,e,o){if(!r||!e||!o)throw new TypeError("[@octokit/webhooks-methods] secret, eventPayload & signature required");let t=u.from(o),a=h(o),s=u.from(await m({secret:r,algorithm:a},e));return t.length!==s.length?!1:g(t,s)}n.VERSION=f;async function R(r,e,o,t){if(await n(r,e,o))return!0;if(t!==void 0)for(let s of t){let c=await n(s,e,o);if(c)return c}return!1}export{m as sign,n as verify,R as verifyWithFallback};
//# sourceMappingURL=webhooks-methods.mjs.map